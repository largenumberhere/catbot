//atempt 2

use std::{path::PathBuf, time::Duration};

use notify::{RecursiveMode, Watcher, Config};





pub fn cat_reader(){
    let file_name = "./";
    let path = PathBuf::from(file_name);
    println!("{:?}",path.canonicalize().unwrap());
    
    let handler =|result: Result<notify::Event, notify::Error>| {
        let event: notify::Event = match result {
            Err(e) =>{ println!("error with event!\n{:?}",e); return;},
            Ok(v)=>{v}
        };

        println!("event occoured: {:?}",event)
    };

    let notifier_config:notify::Config = Config::default()
        .with_poll_interval(Duration::from_millis(100))
        .with_compare_contents(true)
    ;

    let file_update_notifier: Result<notify::ReadDirectoryChangesWatcher, notify::Error> = 
        notify::RecommendedWatcher::new(handler, notifier_config);
    file_update_notifier
        .unwrap()
        .watch(path.as_path(), RecursiveMode::Recursive)
        .unwrap();

    loop {
        
        std::thread::sleep(Duration::from_millis(100));
        print!("."); std::io::Write::flush(&mut std::io::stdout()).unwrap();
    }

    

    

}